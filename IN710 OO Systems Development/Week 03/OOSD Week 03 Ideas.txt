The Observer and Decorator Patterns

Observer:
    There are lots of ways of showing people updates.
	For instance, you can poll a central repository.
	Problem: You only get updates after a poll, but they may
	have occurred just after the last update.
	(This may be OK.  Polling is simple and robust.)
	
	Pushing rather than polling is great, but maybe you
	don't want to broadcast to everyone all the time.
	
	The Observer Pattern sets up a publisher/subscriber system,
	and it still requires you to make a few choices.
	
	Key idea: if a thing is observable, it needs to store
	a container of references to things observing it.
	Then, the things observing it need to register (i.e. get added
	to the container).
	Then, every time the Observable object's state changes, it
	notifies everything in the list of observers.
	
	Thing to decide when using the Observer pattern: will the notify
	be lightweight or rich?  Do I just tell my observers "something changed"
	and let them poll to find out what, or do I send all the changes that you
	might be interested in?
	
	Java provides Observer and Observable classes that you can inherit from.
	(Unfortunately, with single inheritance, it means you can't inherit
	from anything else.)
	
Decorator:
	The Decorator pattern allows you to enhance functionality
	by adding (rather than modifying) code.
	So, if you have a method that is already in production,
	you don't want to change it.  But, sometimes you want it
	to do something else.  The idea is that you decorate it
	so that it can still be called unchanged, but it can now also
	be called via the decorated version.
	
	How? Create a class that has the same interface as the one to
	be decorated (make it a child class, using inheritance. 
	One of its data fields should be an instance of the
	(undecorated) class.  To decorate a method, override the parent
	method.  But don't rewrite the entire method: instead, write
	code to be executed before the method and code to be executed after.
	In the middle, call the parent method (from the instance saved as
	the data field).
	
	In the main program you can now create an instance of the
	object, and then pass the result to as many "wrappers" as
	you wish.
	
	e.g., when A is the parent class, and B, C, D, are all children
	of A, 
	
	C(B(A())).x()    # should work
	B(C(A())).x()    # should also work
	C(D(B(A()))).x() # should work
	
	In Python, there are things called function decorators.
	They wrap a function x by returning a new function y which runs
	code, runs the function x, then runs more code.

	
	